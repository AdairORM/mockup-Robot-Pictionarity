<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interfaz de Control - Robot Pictionary</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .canvas-container {
            touch-action: none;
        }
        .tool-btn.active {
            background-color: #4f46e5;
            color: white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl bg-white rounded-2xl shadow-lg p-6">
        
        <!-- Encabezado y Estado de Conexión -->
        <header class="flex justify-between items-center mb-4 pb-4 border-b">
            <h1 class="text-2xl font-bold text-gray-800">Control del Manipulador</h1>
            <div id="connection-status" class="flex items-center space-x-2 px-3 py-1.5 bg-red-100 text-red-700 rounded-full text-sm font-medium">
                <i class="fas fa-wifi"></i>
                <span>Desconectado</span>
            </div>
        </header>

        <main>
            <!-- Área de Dibujo -->
            <p class="text-gray-600 mb-4 text-center">Dibuja en el lienzo para enviar las trayectorias al robot.</p>
            <div class="canvas-container bg-gray-50 border-2 border-dashed border-gray-300 rounded-xl overflow-hidden aspect-video">
                <canvas id="drawing-canvas"></canvas>
            </div>

            <!-- Barra de Herramientas -->
            <div class="flex items-center justify-center space-x-3 mt-6">
                <button id="tool-line" class="tool-btn active flex items-center justify-center w-24 h-12 bg-white border-2 border-gray-200 rounded-lg text-gray-700 font-semibold hover:bg-gray-100 transition-all duration-200" title="Línea Recta (máx 25cm)">
                    <i class="fas fa-minus mr-2"></i>
                    <span>Línea</span>
                </button>
                <button id="tool-arc" class="tool-btn flex items-center justify-center w-24 h-12 bg-white border-2 border-gray-200 rounded-lg text-gray-700 font-semibold hover:bg-gray-100 transition-all duration-200" title="Medio Arco (15cm diámetro)">
                    <i class="fas fa-hat-cowboy mr-2"></i>
                    <span>Arco</span>
                </button>
                 <button id="tool-clear" class="tool-btn flex items-center justify-center w-12 h-12 bg-white border-2 border-gray-200 rounded-lg text-gray-700 font-semibold hover:bg-gray-100 transition-all duration-200" title="Limpiar lienzo">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
            
            <!-- Botón de Acción Principal -->
            <div class="mt-8">
                <button id="draw-button" class="w-full bg-indigo-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-300 transform hover:scale-105 shadow-lg">
                    <i class="fas fa-paper-plane mr-2"></i>
                    Enviar y Dibujar
                </button>
            </div>
        </main>

        <!-- Modal de Notificación -->
        <div id="notification" class="hidden fixed top-5 right-5 bg-green-500 text-white py-2 px-4 rounded-lg shadow-lg transition-opacity duration-300">
            <p>¡Dibujo enviado al robot!</p>
        </div>

    </div>

    <footer class="text-center mt-6 text-gray-500 text-sm">
        <p>Proyecto Robot Pictionary - Facultad de Ingeniería, UNAM</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;

            let drawing = false;
            let currentTool = 'line';
            let startPoint = { x: 0, y: 0 };
            let currentPath = [];
            let permanentPaths = [];

            // Ajustar tamaño del canvas
            function resizeCanvas() {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                redrawPath();
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Lógica de herramientas
            const toolLineBtn = document.getElementById('tool-line');
            const toolArcBtn = document.getElementById('tool-arc');
            const toolClearBtn = document.getElementById('tool-clear');
            const drawButton = document.getElementById('draw-button');
            const notification = document.getElementById('notification');
            const connectionStatus = document.getElementById('connection-status');

            function setActiveTool(tool) {
                currentTool = tool;
                toolLineBtn.classList.toggle('active', tool === 'line');
                toolArcBtn.classList.toggle('active', tool === 'arc');
            }

            toolLineBtn.addEventListener('click', () => setActiveTool('line'));
            toolArcBtn.addEventListener('click', () => setActiveTool('arc'));
            toolClearBtn.addEventListener('click', clearCanvas);

            // Simulación de conexión
            setTimeout(() => {
                connectionStatus.classList.remove('bg-red-100', 'text-red-700');
                connectionStatus.classList.add('bg-green-100', 'text-green-700');
                connectionStatus.innerHTML = `<i class="fas fa-wifi"></i> <span>Conectado (ESP32)</span>`;
            }, 2500);

            // Funciones de dibujo
            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }

            function startDrawing(e) {
                drawing = true;
                startPoint = getMousePos(e.touches ? e.touches[0] : e);
            }

            function draw(e) {
                if (!drawing) return;
                e.preventDefault();
                const currentPoint = getMousePos(e.touches ? e.touches[0] : e);

                clearForPreview();
                ctx.beginPath();
                ctx.strokeStyle = '#4f46e5';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                if (currentTool === 'line') {
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.lineTo(currentPoint.x, currentPoint.y);
                } else if (currentTool === 'arc') {
                    const dx = currentPoint.x - startPoint.x;
                    const dy = currentPoint.y - startPoint.y;
                    const radius = Math.sqrt(dx * dx + dy * dy) / 2;
                    const centerX = startPoint.x + dx / 2;
                    const centerY = startPoint.y + dy / 2;
                    const startAngle = Math.atan2(startPoint.y - centerY, startPoint.x - centerX);
                    const endAngle = Math.atan2(currentPoint.y - centerY, currentPoint.x - centerX);
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                }
                ctx.stroke();
                currentPath = [{...currentPoint}];
            }

            function stopDrawing(e) {
                if (!drawing) return;
                drawing = false;
                
                const endPoint = currentPath.length > 0 ? currentPath[currentPath.length - 1] : (e ? getMousePos(e.touches ? e.changedTouches[0] : e) : startPoint);


                // Añadir el path a la lista permanente
                permanentPaths.push({
                    tool: currentTool,
                    start: startPoint,
                    end: endPoint
                });

                currentPath = [];
                redrawPath(false); // Only redraw without clearing permanent paths
            }

            function clearForPreview() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                redrawPath(false); // Dibuja los paths permanentes sin limpiar el array
            }

            function redrawPath(clearPermanentAfterDraw = false) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                permanentPaths.forEach(path => {
                    ctx.beginPath();
                    ctx.strokeStyle = '#4338ca';
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    if (path.tool === 'line') {
                        ctx.moveTo(path.start.x, path.start.y);
                        ctx.lineTo(path.end.x, path.end.y);
                    } else if (path.tool === 'arc') {
                         const dx = path.end.x - path.start.x;
                        const dy = path.end.y - path.start.y;
                        const radius = Math.sqrt(dx * dx + dy * dy) / 2;
                        const centerX = path.start.x + dx / 2;
                        const centerY = path.start.y + dy / 2;
                        const startAngle = Math.atan2(path.start.y - centerY, path.start.x - centerX);
                        const endAngle = Math.atan2(path.end.y - centerY, path.end.x - centerX);
                        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    }
                    ctx.stroke();
                });
                
                if (clearPermanentAfterDraw) {
                     permanentPaths = [];
                }
            }


            function clearCanvas() {
                permanentPaths = [];
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                console.log("Lienzo limpiado.");
            }

            // Event Listeners
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseleave', stopDrawing);

            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchmove', draw);


            // Simulación de envío
            drawButton.addEventListener('click', () => {
                if (permanentPaths.length === 0) {
                     // Reemplazando alert con un modal o notificación visual
                    const originalText = drawButton.innerHTML;
                    drawButton.innerHTML = '¡Dibuja algo primero!';
                    drawButton.classList.add('bg-red-500', 'hover:bg-red-600');
                    setTimeout(() => {
                        drawButton.innerHTML = originalText;
                        drawButton.classList.remove('bg-red-500', 'hover:bg-red-600');
                    }, 2000);
                     return;
                }
                
                // Aquí iría la lógica para convertir `permanentPaths` a coordenadas
                // y enviarlas por Wifi/Bluetooth al ESP32.
                console.log("Enviando datos al robot:", permanentPaths);

                notification.classList.remove('hidden');
                notification.classList.add('opacity-100');
                
                setTimeout(() => {
                    notification.classList.add('hidden');
                    notification.classList.remove('opacity-100');
                    clearCanvas();
                }, 2000);
            });
        });
    </script>
</body>
</html>